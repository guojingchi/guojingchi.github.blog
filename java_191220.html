<!DOCTYPE HTML>
<!--
	Stellar by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>java_191220</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Header -->
					<header id="header">
						<h1>java_191220</h1>
						<p>错题与基础整理</p>
					</header>

				<!-- Main -->
					<div id="main">

						<!-- Content -->
							<section id="content" class="main">

								<h1><strong>java错题&amp;知识点整理2019-12-20</strong></h1>
<h3><strong>1.关于abstract</strong></h3>
<hr />
<ul>
<li>抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。 </li>
<li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 </li>
<li>抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。 </li>
<li>构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。 </li>
<li>抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。 </li>
<li>abstract类不能与final,static使用。final修饰方法，子类可以调用，但不能覆盖。 </li>

</ul>
<h3><strong>2.在java中，无论在何处调用，使用静态属性必须以类名做前缀?</strong></h3>
<hr />
<p><strong>错</strong>！</p>
<p>如果是本类使用，可以直接就用静态变量名。</p>
<p>如果是其他类使用，可以使用类名来调用，也可以创建一个实例对象来调用。</p>
<p>如果静态变量所在的类是静态类，那么不管在本类里或者在其他外部类，都可以直接使用静态变量名。</p>
<h3><strong>3.关于Java变量</strong></h3>
<hr />
<p>Java语言支持的变量类型有：</p>
<ul>
<li>类变量：独立于方法之外的变量，用 static 修饰。 </li>

</ul>
<ul>
<li>实例变量：独立于方法之外的变量，不过没有 static 修饰。 </li>

</ul>
<ul>
<li>局部变量：类的方法中的变量。 </li>

</ul>
<pre><code class='language-java' lang='java'>public class Test{
 
    static int allClicks=0;    // 类变量
 
    String str = &quot;hello world&quot;;  // 实例变量
 
    public void method() {
        int i = 0;  // 局部变量
    }
}
</code></pre>
<blockquote><h2><strong>Java 局部变量</strong></h2>
<ul>
<li>局部变量声明在方法、构造方法或者语句块中； </li>
<li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁； </li>
<li>访问修饰符不能用于局部变量； </li>
<li>局部变量只在声明它的方法、构造方法或者语句块中可见； </li>
<li>局部变量是在栈上分配的。 </li>
<li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。 </li>

</ul>
</blockquote>
<p>&nbsp;</p>
<blockquote><h2><strong>实例变量</strong></h2>
<ul>
<li>实例变量声明在一个类中，但在方法、构造方法和语句块之外； </li>
<li>当一个对象被实例化之后，每个实例变量的值就跟着确定； </li>
<li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁； </li>
<li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息； </li>
<li>实例变量可以声明在使用前或者使用后； </li>
<li>访问修饰符可以修饰实例变量； </li>
<li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见； </li>
<li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定； </li>
<li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。 </li>

</ul>
</blockquote>
<p>&nbsp;</p>
<blockquote><h2><strong>类变量（静态变量）</strong></h2>
<ul>
<li>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。 </li>
<li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。 </li>
<li>静态变量除了被声明为常量外很少使用。常量是指声明为public/private，final和static类型的变量。常量初始化后不可改变。 </li>
<li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用static声明变量。 </li>
<li>静态变量在第一次被访问时创建，在程序结束时销毁。 </li>
<li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为public类型。 </li>
<li>默认值和实例变量相似。数值型变量默认值是0，布尔型默认值是false，引用类型默认值是null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。 </li>
<li>静态变量可以通过：<em>ClassName.VariableName</em>的方式访问。 </li>
<li>类变量被声明为public static final类型时，类变量名称一般建议使用大写字母。如果静态变量不是public和final类型，其命名方式与实例变量以及局部变量的命名方式一致。 </li>

</ul>
</blockquote>
<h3><strong>4.Java多线程编程</strong></h3>
<hr />
<p>Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</p>
<p>多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。</p>
<p>这里定义和线程相关的另一个术语 -  进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。</p>
<p>线程调度分为协同式调度和抢占式调度，Java使用的是抢占式调度，也就是每个线程将由操作系统来分配执行时间，线程的切换不由线程本身来决定（协同式调度）。<strong>因此线程调度算法是平台独立的</strong>。 </p>
<h4><strong>一个线程的生命周期</strong></h4>
<hr />
<p>线程是一个动态执行的过程，它也有一个从产生到死亡的过程。</p>
<p>下图显示了一个线程完整的生命周期。</p>
<p><img src="https://uploadfiles.nowcoder.com/images/20190917/334190970_1568705402904_F72445A033E5BCC1DA60655E3F98B622" referrerpolicy="no-referrer" alt="图片说明"> </p>
<ul>
<li><p>新建状态:</p>
<p>使用 <strong>new</strong> 关键字和 <strong>Thread</strong> 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 <strong>start()</strong> 这个线程。</p>
</li>
<li><p>就绪状态:</p>
<p>当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。</p>
</li>
<li><p>运行状态:</p>
<p>如果就绪状态的线程获取 CPU 资源，就可以执行 <strong>run()</strong>，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。</p>
</li>
<li><p>阻塞状态:</p>
<p>如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：</p>
<ul>
<li>等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 </li>
<li>同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 </li>
<li>其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。 </li>

</ul>
</li>
<li><p>死亡状态:</p>
<p>一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。</p>
</li>

</ul>
<h4><strong>线程的优先级</strong></h4>
<hr />
<p>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</p>
<p>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。</p>
<p>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</p>
<p>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</p>
<h4><strong>创建一个线程</strong></h4>
<hr />
<p>Java 提供了三种创建线程的方法：</p>
<ul>
<li>通过实现 Runnable 接口； </li>
<li>通过继承 Thread 类本身； </li>
<li>通过 Callable 和 Future 创建线程。 </li>

</ul>
<h4><strong>通过实现 Runnable 接口来创建线程</strong></h4>
<hr />
<p>创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类。</p>
<p>为了实现 Runnable，一个类只需要执行一个方法调用 run()，声明如下：</p>
<pre><code>public void run()
</code></pre>
<p>你可以重写该方法，重要的是理解的 run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。</p>
<p>在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。</p>
<p>Thread 定义了几个构造方法，下面的这个是我们经常使用的：</p>
<pre><code>Thread(Runnable threadOb,String threadName);
</code></pre>
<p>这里，threadOb 是一个实现 Runnable 接口的类的实例，并且 threadName 指定新线程的名字。</p>
<p>新线程创建之后，你调用它的 start() 方法它才会运行。</p>
<pre><code>void  start();
</code></pre>
<p>下面是一个创建线程并开始让它执行的实例：</p>
<pre><code class='language-java' lang='java'>class RunnableDemo implements Runnable {
   private Thread t;
   private String threadName;
 
   RunnableDemo( String name) {
      threadName = name;
      System.out.println(&quot;Creating &quot; +  threadName );
   }
 
   public void run() {
      System.out.println(&quot;Running &quot; +  threadName );
      try {
         for(int i = 4; i &gt; 0; i--) {
            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);
            // 让线程睡眠一会
            Thread.sleep(50);
         }
      }catch (InterruptedException e) {
         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);
      }
      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);
   }
 
   public void start () {
      System.out.println(&quot;Starting &quot; +  threadName );
      if (t == null) {
         t = new Thread (this, threadName);
         t.start ();
      }
   }
}
 
public class TestThread {
   public static void main(String args[]) {
      RunnableDemo R1 = new RunnableDemo( &quot;Thread-1&quot;);
      R1.start();
 
      RunnableDemo R2 = new RunnableDemo( &quot;Thread-2&quot;);
      R2.start();
   }  
}
</code></pre>
<p>编译以上程序运行结果如下：</p>
<pre><code>Creating Thread-1
Starting Thread-1
Creating Thread-2
Starting Thread-2
Running Thread-1
Thread: Thread-1, 4
Running Thread-2
Thread: Thread-2, 4
Thread: Thread-1, 3
Thread: Thread-2, 3
Thread: Thread-1, 2
Thread: Thread-2, 2
Thread: Thread-1, 1
Thread: Thread-2, 1
Thread Thread-1 exiting.
Thread Thread-2 exiting.
</code></pre>
<h4><strong>通过继承Thread来创建线程</strong></h4>
<hr />
<p>创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。</p>
<p>继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。</p>
<p>该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。</p>
<pre><code class='language-java' lang='java'>class ThreadDemo extends Thread {
   private Thread t;
   private String threadName;
 
   ThreadDemo( String name) {
      threadName = name;
      System.out.println(&quot;Creating &quot; +  threadName );
   }
 
   public void run() {
      System.out.println(&quot;Running &quot; +  threadName );
      try {
         for(int i = 4; i &gt; 0; i--) {
            System.out.println(&quot;Thread: &quot; + threadName + &quot;, &quot; + i);
            // 让线程睡眠一会
            Thread.sleep(50);
         }
      }catch (InterruptedException e) {
         System.out.println(&quot;Thread &quot; +  threadName + &quot; interrupted.&quot;);
      }
      System.out.println(&quot;Thread &quot; +  threadName + &quot; exiting.&quot;);
   }
 
   public void start () {
      System.out.println(&quot;Starting &quot; +  threadName );
      if (t == null) {
         t = new Thread (this, threadName);
         t.start ();
      }
   }
}
 
public class TestThread {
 
   public static void main(String args[]) {
      ThreadDemo T1 = new ThreadDemo( &quot;Thread-1&quot;);
      T1.start();
 
      ThreadDemo T2 = new ThreadDemo( &quot;Thread-2&quot;);
      T2.start();
   }  
}
</code></pre>
<p>编译以上程序运行结果如下：</p>
<pre><code>Creating Thread-1
Starting Thread-1
Creating Thread-2
Starting Thread-2
Running Thread-1
Thread: Thread-1, 4
Running Thread-2
Thread: Thread-2, 4
Thread: Thread-1, 3
Thread: Thread-2, 3
Thread: Thread-1, 2
Thread: Thread-2, 2
Thread: Thread-1, 1
Thread: Thread-2, 1
Thread Thread-1 exiting.
Thread Thread-2 exiting.
</code></pre>
<h4><strong>Thread 方法</strong></h4>
<hr />
<p>下表列出了Thread类的一些重要方法：</p>
<figure><table>
<thead>
<tr><th><strong>序号</strong></th><th><strong>方法描述</strong></th></tr></thead>
<tbody><tr><td>1</td><td><strong>public void start()</strong> 使该线程开始执行；<strong>Java</strong> 虚拟机调用该线程的 run 方法。</td></tr><tr><td>2</td><td><strong>public void run()</strong> 如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。</td></tr><tr><td>3</td><td><strong>public final void setName(String name)</strong> 改变线程名称，使之与参数 name 相同。</td></tr><tr><td>4</td><td><strong>public final void setPriority(int priority)</strong>  更改线程的优先级。</td></tr><tr><td>5</td><td><strong>public final void setDaemon(boolean on)</strong> 将该线程标记为守护线程或用户线程。</td></tr><tr><td>6</td><td><strong>public final void join(long millisec)</strong> 等待该线程终止的时间最长为 millis 毫秒。</td></tr><tr><td>7</td><td><strong>public void interrupt()</strong> 中断线程。</td></tr><tr><td>8</td><td><strong>public final boolean isAlive()</strong> 测试线程是否处于活动状态。</td></tr></tbody>
</table></figure>
<p>测试线程是否处于活动状态。 上述方法是被Thread对象调用的。下面的方法是Thread类的静态方法。</p>
<figure><table>
<thead>
<tr><th><strong>序号</strong></th><th><strong>方法描述</strong></th></tr></thead>
<tbody><tr><td>1</td><td><strong>public static void yield()</strong> 暂停当前正在执行的线程对象，并执行其他线程。</td></tr><tr><td>2</td><td><strong>public static void sleep(long millisec)</strong> 在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</td></tr><tr><td>3</td><td><strong>public static boolean holdsLock(Object x)</strong> 当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。</td></tr><tr><td>4</td><td><strong>public static Thread currentThread()</strong> 返回对当前正在执行的线程对象的引用。</td></tr><tr><td>5</td><td><strong>public static void dumpStack()</strong> 将当前线程的堆栈跟踪打印至标准错误流。</td></tr></tbody>
</table></figure>
<h3><strong>实例</strong></h3>
<p>如下的ThreadClassDemo 程序演示了Thread类的一些方法：</p>
<pre><code class='language-java' lang='java'>// 文件名 : DisplayMessage.java
// 通过实现 Runnable 接口创建线程
public class DisplayMessage implements Runnable {
   private String message;
 
   public DisplayMessage(String message) {
      this.message = message;
   }
 
   public void run() {
      while(true) {
         System.out.println(message);
      }
   }
}

</code></pre>
<pre><code class='language-java' lang='java'>// 文件名 : GuessANumber.java
// 通过继承 Thread 类创建线程
 
public class GuessANumber extends Thread {
   private int number;
   public GuessANumber(int number) {
      this.number = number;
   }
 
   public void run() {
      int counter = 0;
      int guess = 0;
      do {
         guess = (int) (Math.random() * 100 + 1);
         System.out.println(this.getName() + &quot; guesses &quot; + guess);
         counter++;
      } while(guess != number);
      System.out.println(&quot;** Correct!&quot; + this.getName() + &quot;in&quot; + counter + &quot;guesses.**&quot;);
   }
}
</code></pre>
<pre><code class='language-java' lang='java'>// 文件名 : ThreadClassDemo.java
public class ThreadClassDemo {
 
   public static void main(String [] args) {
      Runnable hello = new DisplayMessage(&quot;Hello&quot;);
      Thread thread1 = new Thread(hello);
      thread1.setDaemon(true);
      thread1.setName(&quot;hello&quot;);
      System.out.println(&quot;Starting hello thread...&quot;);
      thread1.start();
 
      Runnable bye = new DisplayMessage(&quot;Goodbye&quot;);
      Thread thread2 = new Thread(bye);
      thread2.setPriority(Thread.MIN_PRIORITY);
      thread2.setDaemon(true);
      System.out.println(&quot;Starting goodbye thread...&quot;);
      thread2.start();
 
      System.out.println(&quot;Starting thread3...&quot;);
      Thread thread3 = new GuessANumber(27);
      thread3.start();
      try {
         thread3.join();
      }catch(InterruptedException e) {
         System.out.println(&quot;Thread interrupted.&quot;);
      }
      System.out.println(&quot;Starting thread4...&quot;);
      Thread thread4 = new GuessANumber(75);
 
      thread4.start();
      System.out.println(&quot;main() is ending...&quot;);
   }
}
</code></pre>
<p>运行结果如下，每一次运行的结果都不一样。</p>
<pre><code>Starting hello thread...
Starting goodbye thread...
Hello
Hello
Hello
Hello
Hello
Hello
Goodbye
Goodbye
Goodbye
Goodbye
Goodbye
.......
</code></pre>
<h4><strong>通过 Callable 和 Future 创建线程</strong></h4>
<hr />
<ul>
<li>创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。 </li>
<li>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。 </li>
<li>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。 </li>
<li>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。 </li>

</ul>
<pre><code class='language-java' lang='java'>public class CallableThreadTest implements Callable&lt;Integer&gt; {
    public static void main(String[] args)  { 
        CallableThreadTest ctt = new CallableThreadTest(); 
        FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(ctt); 
        for(int i = 0;i &lt; 100;i++)  { 
            System.out.println(Thread.currentThread().getName()+&quot; 的循环变量i的值&quot;+i);
            if(i==20)  { 
                new Thread(ft,&quot;有返回值的线程&quot;).start(); 
            } 
        } 
        try  { 
            System.out.println(&quot;子线程的返回值：&quot;+ft.get()); 
        } catch (InterruptedException e)  { 
            e.printStackTrace(); 
        } catch (ExecutionException e)  { 
            e.printStackTrace(); 
        } 
    }
    @Override 
    public Integer call() throws Exception  { 
        int i = 0; 
        for(;i&lt;100;i++)  { 
            System.out.println(Thread.currentThread().getName()+&quot; &quot;+i); 
        } 
        return i; 
    } 
}
</code></pre>
<h4><strong>创建线程的三种方式的对比</strong></h4>
<hr />
<ul>
<li>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。 </li>
<li>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。 </li>

</ul>
<h4><strong>线程的几个主要概念</strong></h4>
<hr />
<p>在多线程编程时，你需要了解以下几个概念：</p>
<ul>
<li>线程同步 </li>
<li>线程间通信 </li>
<li>线程死锁 </li>
<li>线程控制：挂起、停止和恢复 </li>

</ul>
<h4><strong>多线程的使用</strong></h4>
<hr />
<p>有效利用多线程的关键是理解程序是并发执行而不是串行执行的。例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。</p>
<p>通过对多线程的使用，可以编写出非常高效的程序。不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了。</p>
<p>请记住，上下文的切换开销也很重要，如果你创建了太多的线程，CPU 花费在上下文的切换的时间将多于执行程序的时间！</p>
<h4><strong>synchronized关键字和volatile关键字比较：</strong> </h4>
<hr />
<ul>
<li>    volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，实际开发中使用 synchronized 关键字的场景还是更多一些。  </li>
<li>   多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞  </li>
<li>   volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。  </li>
<li>   volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。  </li>

</ul>
<h3><strong>5.      <strong>以下</strong> <strong>b</strong>  <strong>的值是：</strong> <strong>byte b = (byte)129</strong></strong></h3>
<hr />
<p>  这题考察的两个知识点：</p>
<p>一、强制转换（主要涉及各个类型占几个字节，这里我只简单说一下byte型占一个字节，也就是8位，int型4个字节，32位）；</p>
<p>二、在计算机系统中，数值一律用<strong>补码</strong>来表示（存储）  </p>
<p>  正数：补码=反码=原码（当然以二进制形式表达）  </p>
<p>  129 int类型（4个字节）二进制： 00000000 00000000 00000000 10000001  </p>
<p>  强制转换byte型后，只有一个字节即 10000001（注意这里从二进制角度看，第一位是符号位，即求负数的补码接下来）  </p>
<p>  只要求出上面原码对应的补码就行了，然后再转换对应的int型数值（因为题干所给的答案都是比较int型）  </p>
<p>  10000001（原码） 对应的反码为1111 1110 </p>
<p>  又补码等于反码+1  </p>
<p>  即1111 1111 该二进制转换int型刚好是-127（1+2+4+8+16+32+64）</p>
<p>  普及一下：正数原码，反码，补码相同  </p>
<p>   负数反码除了符号位不变，其他位取反，补码=反码+1；  </p>
<p>&nbsp;</p>
<h3><strong>6.JVM内存与垃圾回收机制</strong></h3>
<hr />
<p><a href='https://my.oschina.net/91jason/blog/493841' target='_blank' class='url'>https://my.oschina.net/91jason/blog/493841</a>		</p>
<p>Java GC（Garbage  Collection，垃圾收集，垃圾回收）机制，是Java与C++/C的主要区别之一，作为Java开发者，一般不需要专门编写内存回收和垃圾清理代码，对内存泄露和溢出的问题，也不需要像C程序员那样战战兢兢。这是因为在Java虚拟机中，存在自动内存管理和垃圾清扫机制。概括地说，该机制对JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver  Stop）的保证JVM中的内存空间，防止出现内存泄露和溢出问题。</p>
<p>　　关于JVM，需要说明一下的是，目前使用最多的Sun公司的JDK中，自从1999年的JDK1.2开始直至现在仍在广泛使用的JDK6，其中默认的虚拟机都是HotSpot。2009年，Oracle收购Sun，加上之前收购的EBA公司，Oracle拥有3大虚拟机中的两个：JRockit和HotSpot，Oracle也表明了想要整合两大虚拟机的意图，但是目前在新发布的JDK7中，默认的虚拟机仍然是HotSpot，因此本文中默认介绍的虚拟机都是HotSpot，相关机制也主要是指HotSpot的GC机制。</p>
<p>　　Java  GC机制主要完成3件事：确定哪些内存需要回收，确定什么时候需要执行GC，如何执行GC。经过这么长时间的发展（事实上，在Java语言出现之前，就有GC机制的存在，如Lisp语言），Java  GC机制已经日臻完善，几乎可以自动的为我们做绝大多数的事情。然而，如果我们从事较大型的应用软件开发，曾经出现过内存优化的需求，就必定要研究Java GC机制。</p>
<p>　　学习Java GC机制，可以帮助我们在日常工作中排查各种内存溢出或泄露问题，解决性能瓶颈，达到更高的并发量，写出更高效的程序。</p>
<p>　　我们将从4个方面学习Java GC机制，1，内存是如何分配的；2，如何保证内存不被错误回收（即：哪些内存需要回收）；3，在什么情况下执行GC以及执行GC的方式；4，如何监控和优化GC机制。</p>
<p><strong>Java内存区域</strong></p>
<hr />
<p>　　了解Java GC机制，必须先清楚在JVM中内存区域的划分。在Java运行时的数据区里，由JVM管理的内存区域分为下图几个模块：</p>
<p>其中：</p>
<blockquote><p><strong>1，程序计数器（Program Counter Register）</strong>：程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，可以理解为是当前线程的行号指示器。字节码解释器在工作时，会通过改变这个计数器的值来取下一条语句指令。</p>
<p>每个程序计数器只用来记录一个线程的行号，所以它是<strong>线程私有</strong>（一个线程就有一个程序计数器）的。</p>
<p>如果程序执行的是一个Java方法，则计数器记录的是正在执行的虚拟机字节码指令地址；如果正在执行的是一个本地（native，由C语言编写完成）方法，则计数器的值为Undefined，由于程序计数器只是记录当前指令地址，所以不存在内存溢出的情况，因此，程序计数器也是所有JVM内存区域中唯一一个没有定义OutOfMemoryError的区域。</p>
</blockquote>
<p>&nbsp;</p>
<blockquote><p><strong>2，虚拟机栈（JVM Stack）</strong>：一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame），栈帧中存储的有局部变量表、操作站、动态链接、方法出口等，当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。</p>
<p>局部变量表中存储着方法的相关局部变量，包括各种基本数据类型，对象的引用，返回地址等。在局部变量表中，只有long和double类型会占用2个局部变量空间（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。需要注意的是，局部变量表是在编译时就已经确定好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。</p>
<p>虚拟机栈中定义了两种异常，如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StatckOverFlowError（栈溢出）；不过多数Java虚拟机都允许动态扩展虚拟机栈的大小(有少部分是固定长度的)，所以线程可以一直申请栈，直到内存不足，此时，会抛出OutOfMemoryError（内存溢出）。</p>
<p>每个线程对应着一个虚拟机栈，因此虚拟机栈也是线程私有的。</p>
</blockquote>
<p>&nbsp;</p>
<blockquote><p><strong>3，本地方法栈（Native Method Statck）</strong>：本地方法栈在作用，运行机制，异常类型等方面都与虚拟机栈相同，唯一的区别是：虚拟机栈是执行Java方法的，而本地方法栈是用来执行native方法的，在很多虚拟机中（如Sun的JDK默认的HotSpot虚拟机），会将本地方法栈与虚拟机栈放在一起使用。</p>
<p>本地方法栈也是线程私有的。</p>
</blockquote>
<p>&nbsp;</p>
<blockquote><p><strong>4，堆区（Heap）</strong>：堆区是理解Java GC机制最重要的区域，没有之一。在JVM所管理的内存中，堆区是最大的一块，堆区也是Java GC机制所管理的主要内存区域，堆区<strong>由所有线程共享</strong>，在虚拟机启动时创建。堆区的存在是为了<strong>存储对象实例</strong>，原则上讲，所有的对象都在堆区上分配内存（不过现代技术里，也不是这么绝对的，也有栈上直接分配的）。</p>
<p>一般的，根据Java虚拟机规范规定，堆内存需要在逻辑上是连续的（在物理上不需要），在实现时，可以是固定大小的，也可以是可扩展的，目前主流的虚拟机都是可扩展的。如果在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，将会抛出OutOfMemoryError:Java heap space异常。</p>
<p>关于堆区的内容还有很多，将在下节“<strong>Java内存分配机制</strong>”中详细介绍。</p>
</blockquote>
<p>&nbsp;</p>
<blockquote><p><strong>5，方法区（Method Area）</strong>：在Java虚拟机规范中，将方法区作为堆的一个逻辑部分来对待，但事实上，方法区并不是堆（Non-Heap）；另外，不少人的博客中，将Java GC的分代收集机制分为3个代：青年代，老年代，永久代，这些作者将方法区定义为“永久代”，这是因为，对于之前的HotSpot  Java虚拟机的实现方式中，将分代收集的思想扩展到了方法区，并将方法区设计成了永久代。不过，除HotSpot之外的多数虚拟机，并不将方法区当做永久代，HotSpot本身，也计划取消永久代。本文中，由于笔者主要使用Oracle JDK6.0，因此仍将使用永久代一词。</p>
<p>方法区是各个线程共享的区域，用于存储已经被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。</p>
<p>方法区在物理上也不需要是连续的，可以选择固定大小或可扩展大小，并且方法区比堆还多了一个限制：可以选择是否执行垃圾收集。一般的，方法区上执行的垃圾收集是很少的，这也是方法区被称为永久代的原因之一（HotSpot），但这也不代表着在方法区上完全没有垃圾收集，其上的垃圾收集主要是针对常量池的内存回收和对已加载类的卸载。</p>
<p>在方法区上进行垃圾收集，条件苛刻而且相当困难，效果也不令人满意，所以一般不做太多考虑，可以留作以后进一步深入研究时使用。</p>
<p>在方法区上定义了OutOfMemoryError:PermGen space异常，在内存不足时抛出。</p>
<p>运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存储编译期就生成的字面常量、符号引用、翻译出来的直接引用（符号引用就是编码是用字符串表示某个变量、接口的位置，直接引用就是根据符号引用翻译出来的地址，将在类链接阶段完成翻译）；运行时常量池除了存储编译期常量外，也可以存储在运行时间产生的常量（比如String类的intern()方法，作用是String维护了一个常量池，如果调用的字符“abc”已经在常量池中，则返回池中的字符串地址，否则，新建一个常量加入池中，并返回地址）。</p>
</blockquote>
<p>&nbsp;</p>
<blockquote><p><strong>6，直接内存（Direct Memory）</strong>：直接内存并不是JVM管理的内存，可以这样理解，直接内存，就是JVM以外的机器内存，比如，你有4G的内存，JVM占用了1G，则其余的3G就是直接内存，JDK中有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在JVM堆中的DirectByteBuffer来引用。由于直接内存收到本机器内存的限制，所以也可能出现OutOfMemoryError的异常。</p>
</blockquote>
<p><strong>Java对象的访问方式</strong></p>
<hr />
<p>一般来说，一个Java的引用访问涉及到3个内存区域：JVM栈，堆，方法区。</p>
<p>　　以最简单的本地变量引用：Object obj = new Object()为例：</p>
<ul>
<li>Object obj表示一个本地引用，存储在JVM栈的本地变量表中，表示一个reference类型数据；</li>
<li>new Object()作为实例对象数据存储在堆中；</li>
<li>堆中还记录了Object类的类型信息（接口、方法、field、对象类型等）的地址，这些地址所执行的数据存储在方法区中；</li>

</ul>
<p>在Java虚拟机规范中，对于通过reference类型引用访问具体对象的方式并未做规定，目前主流的实现方式主要有两种：</p>
<p><strong>1，通过句柄访问</strong>（图来自于《深入理解Java虚拟机：JVM高级特效与最佳实现》）：</p>
<p><img src="http://static.oschina.net/uploads/img/201508/18104759_mNOV.png" referrerpolicy="no-referrer" alt="img"></p>
<p>通过句柄访问的实现方式中，JVM堆中会专门有一块区域用来作为句柄池，存储相关句柄所执行的实例数据地址（包括在堆中地址和在方法区中的地址）。这种实现方法由于用句柄表示地址，因此十分稳定。</p>
<p><strong>2，通过直接指针访问:</strong>（图来自于《深入理解Java虚拟机：JVM高级特效与最佳实现》）</p>
<p><img src="http://static.oschina.net/uploads/img/201508/18104800_sXk1.png" referrerpolicy="no-referrer" alt="img"></p>
<p>通过直接指针访问的方式中，reference中存储的就是对象在堆中的实际地址，在堆中存储的对象信息中包含了在方法区中的相应类型数据。这种方法最大的优势是速度快，在HotSpot虚拟机中用的就是这种方式。</p>
<p><strong>Java内存分配机制</strong></p>
<hr />
<p>这里所说的内存分配，主要指的是在堆上的分配，一般的，对象的内存分配都是在堆上进行，但现代技术也支持将对象拆成标量类型（标量类型即原子类型，表示单个值，可以是基本类型或String等），然后在栈上分配，在栈上分配的很少见，我们这里不考虑。</p>
<p>Java内存分配和回收的机制概括的说，就是：分代分配，分代回收。对象将根据存活的时间被分为：年轻代（Young  Generation）、年老代（Old Generation）、永久代（Permanent  Generation，也就是方法区）。如下图（来源于《成为JavaGC专家part  I》，<a href='http://www.importnew.com/1993.html' target='_blank' class='url'>http://www.importnew.com/1993.html</a>）：</p>
<p>　　　　<img src="http://static.oschina.net/uploads/img/201508/18104800_PQxV.png" referrerpolicy="no-referrer" alt="img"></p>
<blockquote><p>　　<strong>年轻代（Young Generation）</strong>：对象被创建时，内存的分配首先发生在年轻代（大对象可以直接被创建在年老代），大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的GC机制清理掉（IBM的研究表明，98%的对象都是很快消亡的），这个GC机制被称为Minor GC或叫Young GC。注意，Minor GC并不代表年轻代内存不足，它事实上只表示在Eden区上的GC。</p>
</blockquote>
<p>    年轻代上的内存分配是这样的，年轻代可以分为3个区域：Eden区（伊甸园，亚当和夏娃偷吃禁果生娃娃的地方，用来表示内存首次分配的区域，再贴切不过）和两个存活区（Survivor 0 、Survivor 1）。内存分配过程为（来源于《成为JavaGC专家part  I》，<a href='http://www.importnew.com/1993.html' target='_blank' class='url'>http://www.importnew.com/1993.html</a>）：</p>
<p>　　　　<img src="http://static.oschina.net/uploads/img/201508/18104800_Myku.png" referrerpolicy="no-referrer" alt="img"></p>
<ol>
<li>绝大多数刚创建的对象会被分配在Eden区，其中的大多数对象很快就会消亡。Eden区是连续的内存空间，因此在其上分配内存极快；</li>
<li>最初一次，当Eden区满的时候，执行Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区Survivor0（此时，Survivor1是空白的，两个Survivor总有一个是空白的）；</li>
<li> 下次Eden区满了，再执行一次Minor GC，将消亡的对象清理掉，将存活的对象复制到Survivor1中，然后清空Eden区；</li>
<li> 将Survivor0中消亡的对象清理掉，将其中可以晋级的对象晋级到Old区，将存活的对象也复制到Survivor1区，然后清空Survivor0区；</li>
<li>当两个存活区切换了几次（HotSpot虚拟机默认15次，用-XX:MaxTenuringThreshold控制，大于该值进入老年代，但这只是个最大值，并不代表一定是这个值）之后，仍然存活的对象（其实只有一小部分，比如，我们自己定义的对象），将被复制到老年代。</li>

</ol>
<p>　　从上面的过程可以看出，Eden区是连续的空间，且Survivor总有一个为空。经过一次GC和复制，一个Survivor中保存着当前还活着的对象，而Eden区和另一个Survivor区的内容都不再需要了，可以直接清空，到下一次GC时，两个Survivor的角色再互换。因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的<strong>“停止-复制（Stop-and-copy）”清理法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中）</strong>，这不代表着停止复制清理法很高效，其实，它也只在这种情况下高效，如果在老年代采用停止复制，则挺悲剧的。</p>
<p>　　在Eden区，HotSpot虚拟机使用了两种技术来加快内存分配。分别是bump-the-pointer和TLAB（Thread-Local Allocation  Buffers），这两种技术的做法分别是：由于Eden区是连续的，因此bump-the-pointer技术的核心就是跟踪最后创建的一个对象，在对象创建时，只需要检查最后一个对象后面是否有足够的内存即可，从而大大加快内存分配速度；而对于TLAB技术是对于多线程而言的，将Eden区分为若干段，每个线程使用独立的一段，避免相互影响。TLAB结合bump-the-pointer技术，将保证每个线程都使用Eden区的一段，并快速的分配内存。</p>
<blockquote><p><strong>年老代（Old Generation）</strong>：对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次Young  GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时，将执行Major GC，也叫 Full GC。　　</p>
</blockquote>
<p> 　可以使用-XX:+UseAdaptiveSizePolicy开关来控制是否采用动态控制策略，如果动态控制，则动态调整Java堆中各个区域的大小以及进入老年代的年龄。</p>
<p>　　如果对象比较大（比如长字符串或大数组），Young空间不足，则大对象会直接分配到老年代上（大对象可能触发提前GC，应少用，更应避免使用短命的大对象）。用-XX:PretenureSizeThreshold来控制直接升入老年代的对象大小，大于这个值的对象会直接分配在老年代上。</p>
<p>　　可能存在年老代对象引用新生代对象的情况，如果需要执行Young  GC，则可能需要查询整个老年代以确定是否可以清理回收，这显然是低效的。解决的方法是，年老代中维护一个512 byte的块——”card  table“，所有老年代对象引用新生代对象的记录都记录在这里。Young GC时，只要查这里即可，不用再去查全部老年代，因此性能大大提高。</p>
<p><strong>Java GC机制</strong></p>
<hr />
<p>GC机制的基本算法是：分代收集，这个不用赘述。下面阐述每个分代的收集方法。</p>
<p>　　<strong>年轻代：</strong></p>
<p>　　事实上，在上一节，已经介绍了新生代的主要垃圾回收方法，在新生代中，使用“停止-复制”算法进行清理，将新生代内存分为2部分，1部分  Eden区较大，1部分Survivor比较小，并被划分为两个等量的部分。每次进行清理时，将Eden区和一个Survivor中仍然存活的对象拷贝到 另一个Survivor中，然后清理掉Eden和刚才的Survivor。</p>
<p>　　这里也可以发现，停止复制算法中，用来复制的两部分并不总是相等的（传统的停止复制算法两部分内存相等，但新生代中使用1个大的Eden区和2个小的Survivor区来避免这个问题）</p>
<p>　　由于绝大部分的对象都是短命的，甚至存活不到Survivor中，所以，Eden区与Survivor的比例较大，HotSpot默认是  8:1，即分别占新生代的80%，10%，10%。如果一次回收中，Survivor+Eden中存活下来的内存超过了10%，则需要将一部分对象分配到 老年代。用-XX:SurvivorRatio参数来配置Eden区域Survivor区的容量比值，默认是8，代表Eden：Survivor1：Survivor2=8:1:1.</p>
<p>　　<strong>老年代：</strong></p>
<p>　　老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-整理算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。</p>
<p>   在发生Minor GC时，虚拟机会检查每次晋升进入老年代的大小是否大于老年代的剩余空间大小，如果大于，则直接触发一次Full GC，否则，就查看是否  设置了-XX:+HandlePromotionFailure（允许担保失败），如果允许，则只会进行MinorGC，此时可以容忍内存分配失败；如果不允许，则仍然进行Full GC（这代表着如果设置-XX:+Handle PromotionFailure，则触发MinorGC就会同时触发Full  GC，哪怕老年代还有很多内存，所以，最好不要这样做）。  </p>
<p>　　<strong>方法区（永久代）：</strong></p>
<p>　　永久代的回收有两种：常量池中的常量，无用的类信息，常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证3点：</p>
<ol>
<li>类的所有实例都已经被回收</li>
<li>加载类的ClassLoader已经被回收</li>
<li>类对象的Class对象没有被引用（即没有通过反射引用该类的地方）</li>

</ol>
<p>   永久代的回收并不是必须的，可以通过参数来设置是否对类进行回收。  HotSpot提供-Xnoclassgc进行控制 </p>
<p>   使用-verbose，-XX:+TraceClassLoading、-XX:+TraceClassUnLoading可以查看类加载和卸载信息 </p>
<p>   -verbose、-XX:+TraceClassLoading可以在Product版HotSpot中使用； </p>
<p>   -XX:+TraceClassUnLoading需要fastdebug版HotSpot支持 </p>
<p><strong>垃圾收集器</strong></p>
<hr />
<p>在GC机制中，起重要作用的是垃圾收集器，垃圾收集器是GC的具体实现，Java虚拟机规范中对于垃圾收集器没有任何规定，所以不同厂商实现的垃圾 收集器各不相同，HotSpot  1.6版使用的垃圾收集器如下图（图来源于《深入理解Java虚拟机：JVM高级特效与最佳实现》，图中两个收集器之间有连线，说明它们可以配合使用）：</p>
<p>　　<img src="http://static.oschina.net/uploads/img/201508/18104800_Cqsm.jpg" referrerpolicy="no-referrer" alt="img"></p>
<p>　　</p>
<p>在介绍垃圾收集器之前，需要明确一点，就是在新生代采用的停止复制算法中，“停  止（Stop-the-world）”的意义是在回收内存时，需要暂停其他所  有线程的执行。这个是很低效的，现在的各种新生代收集器越来越优化这一点，但仍然只是将停止的时间变短，并未彻底取消停止。</p>
<ul>
<li>Serial收集器：新生代收集器，使用停止复制算法，使用一个线程进行GC，串行，其它工作线程暂停。使用-XX:+UseSerialGC可以使用Serial+Serial Old模式运行进行内存回收（这也是虚拟机在Client模式下运行的默认值）</li>
<li>ParNew收集器：新生代收集器，使用停止复制算法，Serial收集器的多线程版，用多个线程进行GC，并行，其它工作线程暂停，关注缩短垃圾收集时间。使用-XX:+UseParNewGC开关来控制使用ParNew+Serial Old收集器组合收集内存；使用-XX:ParallelGCThreads来设置执行内存回收的线程数。</li>
<li>Parallel Scavenge  收集器：新生代收集器，使用停止复制算法，关注CPU吞吐量，即运行用户代码的时间/总时间，比如：JVM运行100分钟，其中运行用户代码99分钟，垃  圾收集1分钟，则吞吐量是99%，这种收集器能最高效率的利用CPU，适合运行后台运算（关注缩短垃圾收集时间的收集器，如CMS，等待时间很少，所以适 合用户交互，提高用户体验）。使用-XX:+UseParallelGC开关控制使用Parallel Scavenge+Serial  Old收集器组合回收垃圾（这也是在Server模式下的默认值）；使用-XX:GCTimeRatio来设置用户执行时间占总时间的比例，默认99，即1%的时间用来进行垃圾回收。使用-XX:MaxGCPauseMillis设置GC的最大停顿时间（这个参数只对Parallel  Scavenge有效），用开关参数-XX:+UseAdaptiveSizePolicy可以进行动态控制，如自动调整Eden/Survivor比例，老年代对象年龄，新生代大小等，这个参数在ParNew下没有。</li>
<li>Serial  Old收集器：老年代收集器，单线程收集器，串行，使用标记整理（整理的方法是Sweep（清理）和Compact（压缩），清理是将废弃的对象干掉，只留幸存的对象，压缩是将移动对象，将空间填满保证内存分为2块，一块全是对象，一块空闲）算法，使用单线程进行GC，其它工作线程暂停（注意，在老年代中进行标记整理算法清理，也需要暂停其它线程），在JDK1.5之前，Serial Old收集器与ParallelScavenge搭配使用。</li>
<li>Parallel Old收集器：老年代收集器，多线程，并行，多线程机制与Parallel  Scavenge差不错，使用标记整理（与Serial  Old不同，这里的整理是Summary（汇总）和Compact（压缩），汇总的意思就是将幸存的对象复制到预先准备好的区域，而不是像Sweep（清理）那样清理废弃的对象）算法，在Parallel Old执行时，仍然需要暂停其它线程。Parallel Old在多核计算中很有用。Parallel Old出现后（JDK  1.6），与Parallel Scavenge配合有很好的效果，充分体现Parallel Scavenge收集器吞吐量优先的效果。使用-XX:+UseParallelOldGC开关控制使用Parallel Scavenge +Parallel Old组合收集器进行收集。</li>
<li>CMS（Concurrent Mark Sweep）收集器：老年代收集器，致力于获取最短回收停顿时间（即缩短垃圾回收的时间），使用标记清除算法，多线程，优点是并发收集（用户线程可以和GC线程同时工作），停顿小。使用-XX:+UseConcMarkSweepGC进行ParNew+CMS+Serial Old进行内存回收，优先使用ParNew+CMS（原因见后面），当用户线程内存不足时，采用备用方案Serial Old收集。CMS收集的执行过程是：初始标记(CMS-initial-mark) -&gt; 并发标记(CMS-concurrent-mark)  --&gt;预清理(CMS-concurrent-preclean)--&gt;可控预清理(CMS-concurrent-abortable-preclean)-&gt; 重新标记(CMS-remark) -&gt; 并发清除(CMS-concurrent-sweep)  -&gt;并发重设状态等待下次CMS的触发(CMS-concurrent-reset)</li>

</ul>
<p><strong>具体的说，先2次标记，1次预清理，1次重新标记，再1次清除。 </strong></p>
<p>1，首先jvm根据   -XX:CMSInitiatingOccupancyFraction，   -XX:+UseCMSInitiatingOccupancyOnly来决定什么时间开始垃圾收集；</p>
<p>2，如果设置了   -XX:+UseCMSInitiatingOccupancyOnly，那么只有当old代占用确实达到了-XX:CMSInitiatingOccupancyFraction参数所设定的比例时才会触发cms gc；</p>
<p>3，如果没有设置   -XX:+UseCMSInitiatingOccupancyOnly，那么系统会根据统计数据自行决定什么时候触发cms gc；因此有时会遇到设置了80%比例才cms gc，但是50%时就已经触发了，就是因为这个参数没有设置的原因；</p>
<p>4，当cms gc开始时，首先的阶段是初始标记(CMS-initial-mark)，是stop the world阶段，因此此阶段标记的对象只是从root集最直接可达的对象；</p>
<p>   CMS-initial-mark：961330K（1572864K），指标记时，old代的已用空间和总空间</p>
<p>5，下一个阶段是并发标记(CMS-concurrent-mark)，此阶段是和应用线程并发执行的，所谓并发收集器指的就是这个，主要作用是标记可达的对象，此阶段不需要用户停顿。</p>
<p>    此阶段会打印2条日志：CMS-concurrent-mark-start，CMS-concurrent-mark</p>
<p>6，下一个阶段是CMS-concurrent-preclean，此阶段主要是进行一些预清理，因为标记和应用线程是并发执行的，因此会有些对象的状态在标记后会改变，此阶段正是解决这个问题因为之后的Rescan阶段也会stop the world，为了使暂停的时间尽可能的小，也需要preclean阶段先做一部分工作以节省时间</p>
<p>   此阶段会打印2条日志：CMS-concurrent-preclean-start，CMS-concurrent-preclean</p>
<p>7，下一阶段是CMS-concurrent-abortable-preclean阶段，加入此阶段的目的是使cms gc更加可控一些，作用也是执行一些预清理，以减少Rescan阶段造成应用暂停的时间</p>
<p>   此阶段涉及几个参数：</p>
<p>     -XX:CMSMaxAbortablePrecleanTime：当abortable-preclean阶段执行达到这个时间时才会结束</p>
<p>     -XX:CMSScheduleRemarkEdenSizeThreshold（默认2m）：控制abortable-preclean阶段什么时候开始执行，</p>
<p>   即当eden使用达到此值时，才会开始abortable-preclean阶段</p>
<p>     -XX:CMSScheduleRemarkEdenPenetratio（默认50%）：控制abortable-preclean阶段什么时候结束执行</p>
<p>   此阶段会打印一些日志如下：</p>
<p>   CMS-concurrent-abortable-preclean-start，CMS-concurrent-abortable-preclean，</p>
<p>   CMS：abort preclean due to time XXX</p>
<p>8，再下一个阶段是第二个stop the world阶段了，即Rescan阶段，此阶段暂停应用线程，停顿时间比并发标记小得多，但比初始标记稍长。对对象进行重新扫描并标记；</p>
<p>    YG occupancy：964861K（2403008K），指执行时young代的情况</p>
<p>    CMS remark：961330K（1572864K），指执行时old代的情况</p>
<p>   此外，还打印出了弱引用处理、类卸载等过程的耗时</p>
<p>9，再下一个阶段是CMS-concurrent-sweep，进行并发的垃圾清理</p>
<p>10，最后是CMS-concurrent-reset，为下一次cms gc重置相关数据结构</p>
<p> </p>
<p><strong>有2种情况会触发CMS 的悲观full gc，在悲观full gc时，整个应用会暂停</strong></p>
<blockquote><p>   A，concurrent-mode-failure：预清理阶段可能出现，当cms  gc正进行时，此时有新的对象要进行old代，但是old代空间不足造成的。其可能性有：1，O区空间不足以让新生代晋级，2，O区空间用完之前，无法完成对无引用的对象的清理。这表明，当前有大量数据进入内存且无法释放。</p>
<p> B，promotion-failed：新生代young gc可能出现，当进行young gc时，有部分young代对象仍然可用，但是S1或S2放不下，因此需要放到old代，但此时old代空间无法容纳此。</p>
</blockquote>
<p> </p>
<p><strong>影响cms gc时长及触发的参数是以下2个：</strong></p>
<blockquote><p>     -XX:CMSMaxAbortablePrecleanTime=5000</p>
</blockquote>
<blockquote><p>     -XX:CMSInitiatingOccupancyFraction=80</p>
</blockquote>
<p><strong>解决也是针对这两个参数来的，根本的原因是每次请求消耗的内存量过大</strong></p>
<blockquote><p>解决方式：</p>
<p>  A，针对cms gc的触发阶段，调整   -XX:CMSInitiatingOccupancyFraction=50，提早触发cms gc，就可以缓解当old代达到80%，cms gc处理不完，从而造成concurrent mode failure引发full gc</p>
<p>B，修改-XX:CMSMaxAbortablePrecleanTime=500，缩小CMS-concurrent-abortable-preclean阶段的时间</p>
<p> C，考虑到cms gc时不会进行compact，因此加入   -XX:+UseCMSCompactAtFullCollection</p>
<p>（cms gc后会进行内存的compact）和   -XX:CMSFullGCsBeforeCompaction=4（在full gc4次后会进行compact）参数</p>
</blockquote>
<p> </p>
<p>在CMS清理过程中，只有初始标记和重新标记需要短暂停顿，并发标记和并发清除都不需要暂停用户线程，因此效率很高，很适合高交互的场合。</p>
<p>CMS也有缺点，它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担（CMS默认启动线程数为(CPU数量+3)/4）。</p>
<p>另外，在并发收集过程中，用户线程仍然在运行，仍然产生内存垃圾，所以可能产生“浮动垃圾”，本次无法清理，只能下一次Full  GC才清理，因此在GC期间，需要预留足够的内存给用户线程使用。所以使用CMS的收集器并不是老年代满了才触发Full  GC，而是在使用了一大半（默认68%，即2/3，使用-XX:CMSInitiatingOccupancyFraction来设置）的时候就要进行Full  GC，如果用户线程消耗内存不是特别大，可以适当调高-XX:CMSInitiatingOccupancyFraction以降低GC次数，提高性能，如果预留的用户线程内存不够，则会触发Concurrent Mode Failure，此时，将触发备用方案：使用Serial Old  收集器进行收集，但这样停顿时间就长了，因此-XX:CMSInitiatingOccupancyFraction不宜设的过大。</p>
<p>还有，CMS采用的是标记清除算法，会导致内存碎片的产生，可以使用-XX：+UseCMSCompactAtFullCollection来设置是否在Full GC之后进行碎片整理，用-XX：CMSFullGCsBeforeCompaction来设置在执行多少次不压缩的Full  GC之后，来一次带压缩的Full GC。</p>
<ul>
<li>G1收集器：在JDK1.7中正式发布，与现状的新生代、老年代概念有很大不同，目前使用较少，不做介绍。</li>

</ul>
<p><strong>注意并发（Concurrent）和并行（Parallel）的区别：  </strong></p>
<p>    <strong>并发</strong>是指用户线程与GC线程同时执行（不一定是并行，可能交替，但总体上是在同时执行的），不需要停顿用户线程（其实在CMS中用户线程还是需要停顿的，只是非常短，GC线程在另一个CPU上执行）；  </p>
<p>    <strong>并行</strong>收集是指多个GC线程并行工作，但此时用户线程是暂停的；  </p>
<p>所以，Serial是串行的，Parallel收集器是并行的，而CMS收集器是并发的.  </p>
<h3><strong>7.DBMS</strong></h3>
<hr />
<ul>
<li>原子性：事务是一组不可分割的操作单元，这组单元要么同时成功要么同时失败（由DBMS的事务管理子系统来实现）；</li>
<li>一致性：事务前后的数据完整性要保持一致（由DBMS的完整性子系统执行测试任务）；</li>
<li>隔离性:多个用户的事务之间不要相互影响，要相互隔离（由DBMS的并发控制子系统实现）；</li>
<li>持久性:一个事务一旦提交，那么它对数据库产生的影响就是永久的不可逆的，如果后面再回滚或者出异常，都不会影响已提交的事务（由DBMS的恢复管理子系统实现的）</li>

</ul>
<h3><strong>8.servlet生命周期</strong></h3>
<hr />
<p><img src="https://uploadfiles.nowcoder.com/images/20170823/3252049_1503478423363_D9B23E5A78E8071F0BB0D7E0E456058E" referrerpolicy="no-referrer" alt="img"></p>
<p>&nbsp;</p>

							</section>

					</div>

				<!-- Footer -->
					<footer id="footer">
						<section>
							<h2>Say Something</h2>
							<p>Just keep going on~~~<br/>
							Optimism is the essential part of life<br/>
							Whatever it happens in life 
							it will be ok<br/>
							There is nothing important except life<br/>
							Alive with love <br/>
						You can make it</p>
							
						</section>
						<section>
							<h2>Contact</h2>
							<dl class="alt">
								<dt>Address</dt>
								<dd>NanJing University,HanKou Roud NO.22</dd>
								<dt>Phone</dt>
								<dd>188****8500</dd>
								<dt>Email</dt>
								<dd><a href="#">gjcbetty@163.com</a></dd>
							</dl>
							
						</section>
						
					</footer>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>